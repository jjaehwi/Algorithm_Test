# 정렬 알고리즘

- `정렬(Sorting)`이란 `데이터를 특정한 기준에 따라 순서대로 나열`하는 것을 말합니다.

- 일반적으로 문제 상황에 따라서 적절한 정렬 알고리즘이 공식처럼 사용됩니다.

## 선택 정렬

- 처리되지 않은 데이터 중에서 `가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복`합니다.

- 선택 정렬은 N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 합니다.

- 구현 방식에 따라서 사소한 오차는 있을 수 있지만, 전체 연산 횟수는 다음과 같습니다.

  - N + (N - 1) + (N - 2) + ... + 2

  - 이는 (N^2 + N - 2) / 2 로 표현할 수 있는데, 빅오 표기법에 따라서 O(N^2)이라고 작성합니다.

```
#include <bits/stdc++.h>

using namespace std;

int n = 10;
int arr[10] = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};

int main(void) {
    for (int i = 0; i < n; i++) {
        int min_index = i; // 가장 작은 원소의 인덱스
        for (int j = i + 1; j < n; j++) {
            if (arr[min_index] > arr[j]) {
                min_index = j;
            }
        }
        swap(arr[i], arr[min_index]); // 스와프
    }
    for(int i = 0; i < n; i++) {
        cout << arr[i] << ' ';
    }
}
```

## 삽입 정렬

- 처리되지 않은 데이터를 하나씩 골라 `적절한 위치에 삽입`합니다.

- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작합니다.

- 삽입 정렬의 시간 복잡도는 O(N^2)이며, 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용됩니다.

- 삽입 정렬은 `현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작`합니다.

  - 최선의 경우 O(N)의 시간 복잡도를 가집니다.

```
#include <bits/stdc++.h>

using namespace std;

int n = 10;
int arr[10] = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};

int main(void) {
    for (int i = 1; i < n; i++) {
        // 인덱스 i부터 1까지 감소하며 반복하는 문법
        for (int j = i; j > 0; j--) {
            // 한 칸씩 왼쪽으로 이동
            if (arr[j] < arr[j - 1]) {
                swap(arr[j], arr[j - 1]);
            }
            // 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
            else break;
        }
    }
    for(int i = 0; i < n; i++) {
        cout << arr[i] << ' ';
    }
}
```

## 퀵 정렬

- 기준 데이터를 설정하고 그 `기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법`입니다.

- 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나입니다.

- 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘입니다.

- 가장 기본적인 퀵 정렬은 `첫 번째 데이터를 기준 데이터(Pivot)로 설정`합니다.

- 이상적인 경우 분할이 절반씩 일어난다면 전체 연산 횟수로 O(NlogN)을 기대할 수 있습니다.

  - 너비 X 높이 = N X logN = NlogN

  - 퀵 정렬은 평균의 경우 O(NlogN)의 시간 복잡도를 가집니다.

  - 하지만 최악의 경우 O(N^2)의 시간 복잡도를 가집니다.

```

#include <bits/stdc++.h>

using namespace std;

int n = 10;
int arr[10] = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};

void quickSort(int* arr, int start, int end) {
    if (start >= end) return; // 원소가 1개인 경우 종료
    int pivot = start; // 피벗은 첫 번째 원소
    int left = start + 1;
    int right = end;
    while (left <= right) {
        // 피벗보다 큰 데이터를 찾을 때까지 반복
        while (left <= end && arr[left] <= arr[pivot]) left++;
        // 피벗보다 작은 데이터를 찾을 때까지 반복
        while (right > start && arr[right] >= arr[pivot]) right--;
        // 엇갈렸다면 작은 데이터와 피벗을 교체
        if (left > right) swap(arr[pivot], arr[right]);
        // 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
        else swap(arr[left], arr[right]);
    }
    // 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quickSort(arr, start, right - 1);
    quickSort(arr, right + 1, end);
}

int main(void) {
    quickSort(arr, 0, n - 1);
    for (int i = 0; i < n; i++) {
        cout << arr[i] << ' ';
    }
}
```

## 계수 정렬

- 특정한 조건이 부합할 때만 사용할 수 있지만 `매우 빠르게 동작하는` 정렬 알고리즘입니다.

  - 계수 정렬은 `데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때` 사용 가능합니다.

- 데이터의 개수가 N, 데이터(양수) 중 최댓값이 K일 때 최악의 경우에도 수행 시간 O(N + K)를 보장합니다.

- 계수 정렬의 시간 복잡도와 공간 복잡도는 모두 O(N + K)입니다.

- 계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있습니다.

  - ex) 데이터가 0과 999999로 단 2개만 존재하는 경우..

- 계수 정렬은 `동일한 값을 가지는 데이터가 여러 개 등장할 때` 효과적으로 사용할 수 있습니다.
  - 성적의 경우 100점을 맞은 학생이 여러 명일 수 있기 때문에 계수 정렬이 효과적입니다.

```
#include <bits/stdc++.h>
#define MAX_VALUE 9

using namespace std;

int n = 15;
// 모든 원소의 값이 0보다 크거나 같다고 가정
int arr[15] = {7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2};
// 모든 범위를 포함하는 배열 선언(모든 값은 0으로 초기화)
int cnt[MAX_VALUE + 1];

int main(void) {
    for (int i = 0; i < n; i++) {
        cnt[arr[i]] += 1; // 각 데이터에 해당하는 인덱스의 값 증가
    }
    for (int i = 0; i <= MAX_VALUE; i++) { // 배열에 기록된 정렬 정보 확인
        for (int j = 0; j < cnt[i]; j++) {
            cout << i << ' '; // 띄어쓰기를 기준으로 등장한 횟수만큼 인덱스 출력
        }
    }
}
```

## 정렬 알고리즘 비교

- `선택 정렬`

  - 평균 시간 복잡도 : O(N^2)
  - 공간 복잡도 : O(N)
  - 특징 : 아이디어가 매우 간단합니다.

- `삽입 정렬`

  - 평균 시간 복잡도 : O(N^2)
  - 공간 복잡도 : O(N)
  - 특징 : 데이터가 거의 정렬되어 있을 때는 가장 빠릅니다.

- `퀵 정렬`

  - 평균 시간 복잡도 : O(NlogN)
  - 공간 복잡도 : O(N)
  - 특징 : 대부분의 경우에 가장 적합하며, 충분히 빠릅니다..

- `계수 정렬`

  - 평균 시간 복잡도 : O(N + K)
  - 공간 복잡도 : O(N + K)
  - 특징 : 데이터의 크기가 한정되어 있는 경우에만 사용이 가능하지만 매우 빠르게 동작합니다.
