# 그래프 이론

`그래프 (Graph)`의 정의

- 현실 세계의 `사물`이나 `개념` 간의 `연결 관계`를 수학적 모델로 단순화 하여 표현한 것

- 수학적 정의 : 정점(Vertex, Node) 집합 V = {v1, v2, v3 ,,, vn}이고, 정점간의 연결 관계들을 나타내는 간선(Edge, Link, Arc) 집합 E = {(vi, vj) / vi ∈ V, vj ∈ V} ⊆ V x V 일 때, 그래프 G = (V,E) 이다.

## 그래프 용어

**무향 간선 (Undirected Edge)**

- 정점을 연결하는 `간선에 방향이 존재하지 않는다.`

- 임의의 간선 (vi, vj)에 대해서 (vi, vj) = (vj, vi) 이다.

**유향 간선 (Directed Edge)**

- 정점을 연결하는 `간선에 방향이 존재한다.`

- 임의의 간선 (vi, vj)에 대해서 (vi, vj) != (vj, vi) 이다.

**인접 (Adjacent)**

- 정점 vi, vj 에 대해서 간선 e = (vi, vj)가 존재한다.

- 정점 vi 와 vj 는 인접(adjacent)한다.

**부속 (Incident)**

- 정점 vi, vj 에 대해서 간선 e = (vi, vj)가 존재한다.

- 간선 e는 정점 vi 와 vj 에 부속(incident)한다.

**차수 (Degree)**

- 정점(vertex)에 부속(incident)된 간선(edge)의 수

- in-degree : 방향 그래프에서 정점에 `들어오는` 간선의 수

- out-degree : 방향 그래프에서 정점에서 `나가는` 간선의 수

**경로 (Path)**

- 정점과 간선이 `교대로 구성`된 sequence

- 단순 경로 (Simple Path) : 정점과 간선이 `중복되지 않은` 경로

**회로 (Cycle)**

- `시작 정점과 끝 정점이 같은 경로`

- 단순 회로 (Simple Cycle) : 정점과 간선이 `중복되지 않은` 회로

**연결됨 (Connected)**

- 정점 vi 에서 정점 vj 로의 `경로가 존재`하면, 정점 vi 와 정점 vj 는 연결되어 있다고 한다.

## 그래프 종류

**무향 그래프 (Undirected Graph)**

- `무향 간선`으로 이루어진 그래프

**유향 그래프 (Directed Graph)**

- `유향 간선`으로 이루어진 그래프

**가중치 그래프 (Weighted Graph)**

- `가중치 or 비용` 을 가지는 간선으로 이루어진 그래프

**정규 그래프 (Regular Graph)**

- 모든 정점이 `동일한 차수`를 가지는 그래프

**완전 그래프 (Complete Graph)**

- `모든 정점에서 모든 정점으로 갈 수 있다.`

- 임의의 두 정점 vi, vj 에 대해서 vi, vj 를 잇는 간선 Edge(vi, vj)이 존재하는 그래프

- 완전 그래프는 정규 그래프이다.

- N개의 정점을 가지는 `무향 그래프`의 경우 : 간선의 개수 = `1/2 N(N-1)`

- N개의 정점을 가지는 `유향 그래프`의 경우 : 간선의 개수 = `N(N-1)`

**연결 그래프 (Connected Graph)**

- 임의의 두 정점 vi, vj 에 대해서 경로 Path(vi, vj)가 존재하는 그래프

**부분 그래프**

- 어떤 그래프의 정점 집합의 부분 집합과 그에 속한 간선들로 이루어진 그래프

- 어떤 그래프의 간선 집합의 부분 집합과 그에 속한 정점들로 이루어진 그래프

**트리 그래프**

- `순환을 갖지 않는 연결 그래프`

- 임의의 두 정점에 대해서 경로가 정확히 1개 존재한다.

- 하나 이상의 정점을 가지며, 임의의 간선 e 를 제거한 그래프는 연결 그래프가 아니다.

## 최단 경로(shortest path) 알고리즘

- 최단 경로 문제란 `가중 그래프에서 간선의 가중치의 합이 최소`가 되는 경로를 찾는 문제이다.

**최단 경로 문제의 종류**

1. 단일 출발 (single-source) 최단 경로

   - 어떤 하나의 정점에서 출발하여 나머지 모든 정점 까지의 최단 경로를 찾는 문제

2. 단일 도착 (single-destination) 최단 경로

   - 모든 정점에서 출발하여 어떤 하나의 정점까지의 최단 경로를 찾는 문제

   - 그래프 내의 간선들을 뒤집으면 단일 출발 최단거리 문제로 바뀔 수 있다.

3. 단일 쌍 (single-pair) 최단 경로

   - 어떤 정점 v 에서 v' 로 가는 최단 경로를 구하는 문제

4. 전체 쌍 (all-pair) 최단 경로

   - 모든 정점 쌍들 사이의 최단 경로를 찾는 문제

**주요 알고리즘**

1. BFS (완전 탐색 알고리즘)

   - `가중치가 없거나 모든 가중치가 동일한 그래프`에서 최단경로를 구하는 경우 가장 빠름

2. 다익스트라 알고리즘

   - `음이 아닌 가중 그래프에`서의 단일 쌍, 단일 출발, 단일 도착 최단 경로 문제

3. 벨만-포드 알고리즘

   - `음수도 가능한 가중 그래프`에서의 단일 쌍, 단일 출발, 단일 도착 최단 경로 문제

   - 다익스트라보다 느림

4. 플로이드 워셜 알고리즘

   - `전체 쌍 최단 경로` 문제

### 1. 다익스트라 (Dijkstra)

- V 개의 정점과 `음수가 아닌 E 개의 간선`을 가진 그래프 G에서 `특정 출발 정점 (S)에서 부터 다른 모든 정점`까지의 최단 경로를 구하는 알고리즘

**특징**

- 각 정점을 최대 한번씩만 방문하여 최단 거리를 확정한다. 그러므로 `음의 가중치를 가질 수 없다.`

- `아직 방문하지 않은 정점들 중 최단 거리인 점을 찾아 방문하여 최단 거리를 확정`하고, 이를 반복하는 식으로 진행된다.

- 총 V x V 번 연산이 필요하다. 따라서 `O(V^2)`의 시간 복잡도를 가진다.

- 방문하지 않은 정점 중에서 최단 거리가 최소인 정점을 찾는 과정에서 `우선순위 큐 혹은 힙 자료구조`를 이용하면 더욱 개선된 알고리즘이 가능하다.

- 우선순위 큐 나 최소 힙을 사용하여 다음에 갈 지점을 큐에 넣는 것! -> 최대 E 번의 정점을 큐에 넣게 되고 하나의 정점을 꺼낼 때 마다 logE 연산이 필요하다. -> `O(ElogV) 의 시간 복잡도`를 가진다.

**동작 및 구현**

`노드 설정 및 간선 연결` : 벡터의 크기를 재할당 한 후 해당 노드에 간선과 가중치를 넣어준다.

```
adj.resize(V + 1);
for (int i = 0; i < E; i++)
    {
        int u, v, w;
        cin >> u >> v >> w;
        adj[u].push_back({v, w});
    }
```

`초기화` : 우선 순위 큐를 만들고 모든 정점의 최단거리를 무한대로 초기화한다. 그리고 시작점을 큐에 넣은 후 현재 최단거리 dist를 0으로 초기화한다.

```
 priority_queue<edge> pq; // 우선 순위 큐

    // 초기화
    // 우선 모든 정점의 최단거리를 무한대로 숫자를 정해둔다.
    for (int i = 0; i <= V; i++)
        dist[i] = INF;

   // 시작점을 큐에 넣고, dist를 0으로 설정한다.
    pq.push({startNode, 0});
    dist[startNode] = 0;
```

`최단 거리 갱신` : 큐에서 값을 하나씩 꺼내 해당 정점에서 나가는 간선들을 전부 순회하며 다음으로 가는 정점들에 대한 가중치(최단 거리)를 계산한다. 다음에 갈 점의 최단거리보다, 지금 점 + 다음 점으로의 가중치가 더 작다면 최단거리를 갱신하고, 큐에 해당 지점을 넣는다.

```
    // 우선순위 큐에서 값을 꺼내온다.
    while (!pq.empty())
    {
        edge top = pq.top();
        pq.pop();

        int nowVertex = top.end; // 현재의 정점
        int nowCost = top.cost;

        // 안써도 무관한데,, 시간 좀 줄어듬
        if (dist[nowVertex] < nowCost)
            continue;

        // 해당 정점에서 나가는 간선들을 순회하여, 다음 갈 수 있는 정점들에 대해 가중치(최단거리)를 계산한다.
        int len = adj[nowVertex].size();
        for (int i = 0; i < len; i++)
        {
            edge next = adj[nowVertex][i];

            // 다음에 갈 점의 최단거리보다, 지금 점 + 다음 점으로의 가중치가 더 작다면
            // 최단거리를 갱신하고, 큐에 해당 지점을 넣는다.
            if (dist[next.end] > dist[nowVertex] + next.cost)
            {
                dist[next.end] = dist[nowVertex] + next.cost;
                pq.push({next.end, dist[next.end]}); // 다음에 갈 지점을 큐에 넣어야한다! 최단거리는 방금 계산한 그 값으로 넣어야한다. (현재의 최단거리)
                // 갱신이 되는 것들에 대해서만 큐에 넣어서 확인한다.
            }
        }
    }
```

ex) [연습문제 백준 1753번](https://github.com/jjaehwi/Algorithm_Test/blob/main/백준/Graph/1753.cpp)

### 2. 벨만-포드 (Bellman-Ford)

- V 개의 정점과 E 개의 간선을 가진 가중 그래프 G 에서 `특정 출발 정점 (S)에서 부터 다른 모든 정점까지의 최단 경로`를 구하는 알고리즘

- V 개의 정점과 E 개의 간선을 가진 가중 그래프에서 어떤 정점 A 에서 어떤 정점 B 까지의 최단 거리는 `최대 V - 1 개의 간선을 사용`한다. (= 시장 정점 A 를 포함하여 최대 V 개의 정점을 지닌다.)

**특징**

- `음의 가중치를 가지는 간선도 가능`하다.

- `음의 사이클의 존재 여부를 확인`할 수 있다.

- 최단 거리를 구하기 위해서 `V - 1 번` E 개의 모든 간선을 확인한다.

- 음의 사이클 존재 여부를 확인하기 위해서 한 번 더 E 개의 간선을 확인한다. -> V - 1 + 1(음의 사이클) = V 번 도는 것

- 총 연산 횟수는 `V x E`이다. 따라서 시간 복잡도는 O(VE) 이다.

- V 번째 모든 간선을 확인 하였을 때 `거리 배열이 갱신되었다면, 그래프 G 는 음의 사이클`을 가지는 그래프이다.

**동작 및 구현**

`초기화` : 초기의 최소 비용을 저장하는 배열을 INF 로 초기화한다.

```
    // fill(dist, dist + n, INF);
    // dist 전체를 INF로 채운다.
    for (int i = 1; i <= n; i++)
        dist[i] = INF; // 모든 노드를 INF로 세팅
```

`업데이트` : 모든 간선들을 탐색하면서, 간선이 잇는 출발 정점이 `한번이라도 계산된 정점` 이라면 간선이 잇는 정점의 거리를 비교해서 업데이트 한다.

`음수 사이클 찾기` : n-1 루프가 끝나면 현재 인덱스의 인접 리스트에 대해 순회하면서 음수 사이클을 찾는다. 업데이트 할 때 같이 반복문안에 넣어서 구현도 가능하다.

```
// 음의 사이클이 존재하면 false 반환
bool belman(int n)
{
    // 첫 시작점의 최단거리 값을 0으로 만든다.
    dist[1] = 0;

    // 3. N-1번 루프하면서 전체에 대한 최단거리를 찾는다. (핵심)
    for (int i = 0; i < n - 1; i++)
    {
        // 2. 현재 정점의 인덱스를 now로 하여, 정점 전체를 순회한다. (핵심) 전체 정점에 대해서 1~n 까지
        // 숫자의 시작을 1로 하고 있음. 주의할 것
        for (int now = 1; now <= n; now++)
        {
            // 1. 현재 인덱스의 인접리스트에 대해 순회 시작
            int len = adj[now].size();
            for (int adjIdx = 0; adjIdx < len; adjIdx++)
            {
                int nextNode = adj[now][adjIdx].end;
                int nextCost = adj[now][adjIdx].cost;

                // 현재 값이 INF가 아니면서(최소 한번 최단거리 갱신된 적이 있음)
                // 최단거리가 갱신되는 경우(현재 최단거리 + cost가 기존 최단거리보다 작음)
                if (dist[now] != INF && dist[nextNode] > dist[now] + nextCost)
                {
                    dist[nextNode] = dist[now] + nextCost;
                    // N 번째 루프에서 최단거리가 갱신되었음 음의 사이클이 존재한다는 것
                    // if(i==n-1){
                    //    return false;
                    // }
                }
            }
        }
    }

    // 4. n-1 루프가 끝나면, 마지막으로 한번 더 순회하여 음수 사이클을 찾는다.
    for (int now = 1; now <= n; now++)
    {
        // 1. 현재 인덱스의 인접리스트에 대해 순회 시작
        int len = adj[now].size();
        for (int adjIdx = 0; adjIdx < len; adjIdx++)
        {
            int nextNode = adj[now][adjIdx].end;
            int nextCost = adj[now][adjIdx].cost;

            // N번째 루프에서 최단거리가 갱신되었음! 음의 사이클 존재
            if (dist[now] != INF && dist[nextNode] > dist[now] + nextCost)
                return false;
        }
    }
    return true;
}
```

ex) [연습문제 백준 11657번](https://github.com/jjaehwi/Algorithm_Test/blob/main/백준/Graph/11657.cpp)

### 3. 플로이드-워셜 (Floyd-Warshall)

- V 개의 정점과 E 개의 간선을 가진 가중 그래프 G 에서 `모든 정점 사이의 최단 경로`를 구하는 알고리즘

- 어떤 `두 정점 사이의 최단 경로는 어떤 경유지 (K) 를 거치거나 거치지 않은 경로 중 하나`이다. 즉, 정점 A 와 정점 B 사이의 최단 경로는 A - B 이거나 A - K - B 이다.

- 만약 `경유지 (K) 를 거친다면 최단 경로를 이루는 부분 경로 역시 최단 경로`이다. 즉, A - B 의 최단 경로가 A - K - B 라면 A - K, K - B 도 각각 최단 경로 이다.

**특징**

- `순환만 없다면 음수 가중치도 가능`하다.

- 기본적으로 `동적 계획법으로 접근`한다.

- 모든 가능한 경유지에 대해서 모든 정점에서 모든 정점으로 가는 최단 거리를 확인하므로 연산 횟수는 V^3 이고, 따라서 `시간 복잡도는 O(V^3)` 이다.

**동작 및 구현**

`초기화` : dist[i][j] 는 정점 i 에서 정점 j 까지의 최단 거리를 저장하는 배열이고 처음 자기자신을 제외한 모든 정점까지의 거리를 INF 로 초기화 한다. (행렬 초기화)

```
for (int i = 0; i <= n; i++)
        for (int j = 0; j <= n; j++)
            dist[i][j] = i == j ? 0 : INF;
```

`점화식` : i 부터 j 까지, i ~ k 개의 정점을 이용하여 최단 거리를 구한다. N번 만큼 단계를 반복하여 점화식에 맞게 2차원 리스트를 갱신 하는 것

```
void floyd(int n)
{
    // 플로이드 워셜
    // i부터 j까지, 1~k개의 정점을 이용하여 최단거리를 구한다.
    // DP를 사용하는 문제!
    // N번만큼의 단계를 반복하며, '점화식에 맞게' 2차원 리스트를 갱신하는 것..

    // 1. 현재 단계를 k번째라고 할 때
    //    현재 dist에는 1~k-1번째 정점을 사용해서 나올 수 있는 최단거리가 남아있다.
    //    1 ~ k 의 정점을 이용하여 도달가능한 최단거리를 구함
    //    DP이므로 과거의 값을 이용하여 다음 값을 구하는 방식!

    // 2. 점화식
    //    두 정점 i, j에 대해 k번 정점을 지나가면서 가면 최단거리가 더 짧아지는가?
    //    즉, 기존 i -> j 보다 i -> k -> j 가 더 짧은 최단거리를 가지는지 확인

    // 3. 위의 점화식을 모든 (i,j)에 적용함
    //    조건 => if(dist[i][j] > dist[i][k] + dist[k][j])
    //    위 if문으로 판단하면서 기존보다 빨라지면 최단거리 갱신을 한다.
    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                // 최단거리가 더 짧은걸 dist로 갱신
            }
        }
    }
}
```

ex) [연습문제 백준 11404번](https://github.com/jjaehwi/Algorithm_Test/blob/main/백준/Graph/11404.cpp)

## 서로소 집합 (Disjoint Set, Union-Find)

- 교집합이 공집합인 `집합(서로소 집합) 들의 정보를 확인(Find)하고 조작(Union)`할 수 있는 자료구조

**Union 연산**

- 어떤 두 원소 a, b 에 대해서 union(a, b) 는 `각 원소가 속한 집합을 하나로 합치는 연산`

- a ∈ A, b ∈ B 에 대해서, union(a, b) 는 A U B 이다.

**Find 연산**

- 어떤 원소 a 에 대해서 a 가 속한 `집합(집합의 대표 번호)을 반환`

- a ∈ A 에 대해서, find(a) 는 집합 A (집합 A의 대표 번호)를 반환

**서로소 집합의 구현 및 최적화**

`초기화` : parent 배열에 i 원소에 대한 부모 노드 번호를 저장, 루트 노드인 경우 자기 자신의 번호를 저장

```
void initParent(int n)
{
    for (int i = 0; i <= n; i++)
        parent[i] = i;
}
```

`Union 연산` : 하나의 루트 노드를 다른 하나의 루트 노드의 자식 노드로 넣어 두 트리를 합친다.

```
void merge(int a, int b)
{
    // 1. 두 개의 루트를 각각 찾는다.
    a = find(a);
    b = find(b);

    // 2. 루트가 같다면 두 개는 이미 union 되어 있으므로 종료한다. (이미 merge 되어있다는 의미로 true 반환)
    if (a == b)
        return;

    // 루트가 다르다면 a의 루트를 b로 설정 (거꾸로 해도 상관 x)
    parent[a] = b;
}
```

`Find 연산` : 주어진 원소의 루트 노드 번호를 반환한다.

```
int find(int n)
{
    if (n == parent[n])
        return n;

    int result = find(parent[n]);
    parent[n] = result;
    return result;
    // 중간에 부모값을 계속 갱신해주는 것
    // return parent[n] = find(parent[n]);
}
```

ex) [연습문제 백준 1717번](https://github.com/jjaehwi/Algorithm_Test/blob/main/백준/Graph/1717.cpp)

### 최소 신장 트리 (Minimum Spanning Tree)

**트리와 그래프 관계**

- 트리는 그래프 중에서 특수한 경우에 해당하는 자료구조로, `사이클이 존재하지 않는 방향 그래프`다.

**신장 트리(Spanning Tree)**

- 그래프 상에서 `모든 노드가 사이클 없이 연결된 부분 그래프`를 뜻한다. 이 부분 그래프는 여러개가 존재할 수 있다.

**깊이 우선(DFS) 신장 트리**

- 무향 연결 그래프 G 에서 깊이 우선 탐색 (DFS) 으로 탐색하면서 생성된 신장 트리

**너비 우선(BFS) 신장 트리**

- 무향 연결 그래프 G 에서 너비 우선 탐색 (BFS) 으로 탐색하면서 생성된 신장 트리

**최소 신장 트리**

- 여러 개의 부분 그래프 중 `모든 정점이 최소 간선의 합`으로 연결된 부분 그래프이다.

- 무향 연결 가중 그래프 G 에서 `간선의 가중치의 합이 최소`인 신장 트리

<img width="583" alt="스크린샷 2023-02-11 오후 8 00 26" src="https://user-images.githubusercontent.com/87372606/218254523-b4eef0c5-200d-446b-8516-6daf4940b687.png">

### 1. 크루스칼 (간선이 적은 경우)

- `간선 기준`이고 `union - find` 를 사용한다. 합치고 `유망한지 판단`한다.

- 가장 적은 비용으로 모든 노드를 연결할 수 있다.

- 그리디 알고리즘

- `시간 복잡도`: 알고리즘에서 시간이 가장 오래 걸리는 부분이 간선 정렬이므로, 간선의 개수가 E개일 때 O(ElogE)

**크루스칼 알고리즘 구현**

1. `간선에 대한 정렬`이 필요하다.

2. 간선을 하나씩 확인하며 현재의 `간선이 사이클을 발생시키는지 유망을 판단`한다.

   2.1 사이클이 발생하지 않는 경우 최소 신장 트리에 포함

   2.2 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않음

3. 모든 간선에 대해 2번 과정을 `반복`한다.

4. `간선의 개수가 N-1 이 될 때 전부 연결`된 것이므로 종료한다.

지금 있는 정점에서 나가는 정점 중 제일 작은 걸 포함시킨다. -> 최소 힙 -> 우선 순위 큐 (priority queue)

```
int MST(int vertex)
{
    int currentWeight = 0;
    int mstEdgeCount = 0;
    // union - find 초기화
    initParent(vertex);
    // 가중치에 대해 오름차순 정렬
    sort(vecEdge.begin(), vecEdge.end(), compare);
    // 간선 순회
    for (int i = 0; i < vecEdge.size(); i++)
    {

        // 두개가 같은 집합이 아니면 (두개가 연결되어있지 않으면) MST에 해당 간선을 포함시켜주고, 그때의 가중치를 더하고, edge의 수를 1개 올린다.
        // merge 되면서 parent들을 전부 갱신시켜 주기 때문에 결과값만 if문으로 확인하면 된다.
        if (merge(vecEdge[i].start, vecEdge[i].end) == false)
        {
            currentWeight += vecEdge[i].weight;
            mstEdgeCount++;
        }
        // 간선이 N-1개가 되면 전부 연결된 것이므로 종료한다.
        if (mstEdgeCount == N - 1)
            break;
    }
    return currentWeight;
}
```

ex) [백준 1922번](https://github.com/jjaehwi/Algorithm_Test/blob/main/백준/Graph/1922.cpp)

### 2. 프림 (간선이 많은 경우)

- `정점 기준` 이다.

## 위상 정렬 (Topological Sort)

- `DAG (비순환 방향 그래프)에서 그래프의 방향성을 거스르지 않고 정점들을 나열하는 것`

- 위상 정렬은 `각 정점을 우선순위에 따라 배치`한 것

- 일반적으로 위상 정렬의 결과는 `유일하지 않다` (Indegree 가 0 인게 여러개일 수 있기 때문)

진입 차수가 없다는 것 -> 돌아올 수 없다 -> 우선 순위가 가장 높은 것 -> 가장 처음에 동작하는 것

`어떤 순서나 선행, 그래프` 에 관한 얘기가 나오면 위상 정렬을 의심해보자..

ex) [백준 1516번](https://github.com/jjaehwi/Algorithm_Test/blob/main/백준/Graph/1516.cpp)

**위상 정렬의 동작**

1. 진입 차수가 0 인 노드를 큐에 넣는다.

2. 큐가 빌 때까지 다음의 과정을 반복한다.

   2.1 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.

   2.2 새롭게 진입 차수가 0 이 된 노드를 큐에 넣는다.

- 큐가 빌 때까지 원소를 계속 꺼내서 처리하는 과정을 반복하고, 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 판단 가능하다.

- 사이클이 존재하는 경우 사이클에 포함되어 있는 원소 중에서 어떠한 원소도 큐에 들어가지 못하기 때문이다.

### DAG (Directed Acyclic Graph)

- DAG 는 `순환을 가지지 않는 방향그래프`를 말한다.

- 일반적으로 `우선 순위`를 가진 일련의 작업들은 DAG 구조를 가진다.

ex 1) 스타크래프트에서 건물 짓는 순서

ex 2) 대학 과정의 선수 과목

`선행자(predecessor) 와 후행자(successor)`

- DAG 에서 어떤 정점 vi ∈ V, vj ∈ V 에 대해서 vi 에서 vj 로의 `경로`가 존재하면, vi 를 vj 의 선행자, vj 는 vi 의 후행자라 한다.

`즉각 선행자(immediate predecessor) 와 즉각 후행자(immediate successor)`

- DAG 에서 어떤 정점 vi ∈ V, vj ∈ V 에 대해서 vi 에서 vj 로의 `간선`이 존재하면, vi 를 vj 의 즉각 선행자, vj 는 vi 의 즉각 후행자라 한다.

추가해야할 것.
LCA (최소 공통 조상)
단절점과 단절선
