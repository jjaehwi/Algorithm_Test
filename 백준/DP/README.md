# Dynamic Programming (DP)

- **DP 는 큰 문제를 작은 문제로 쪼개서 해결한다 (`Devide-and-Conquer`) 라는 원리에 기반을 두고 있으며, 이전에 계산해둔 값을 메모리 (배열 등) 에 저장해서 반복 작업을 줄이는 기법 (`Memoization`) 이 핵심**

- 어떤 문제를 DP로 풀기 위해서는 `최적의 원리 (Principle of Optimality)` 가 성립하는지를 확인해야 하는데, 최적의 원리란 다음과 같다.

  - "어떤 문제의 입력사례의 최적해가 그 입력사례를 분할한 부분사례에 대한 최적해를 항상 포함하고 있으면, 그 문제에 대하여 최적의 원리가 성립한다."

---

## 0 - 1 knapsack

- 집합 A 가 n 번째 보석을 포함하고 있지 않다면, A 는 n 번째 보석을 뺀 나머지 n-1 개의 보석들 중에서 최적으로 고른 부분집합과 같다.

- 집합 A 가 n 번째 보석을 포함하고 있다면, A 에 속한 보석들의 총 가격은 n-1 개의 보석들 중에서 최적으로 고른 가격의 합에다가 보석 n 의 가격을 더한 것과 같다. (단, n 번째 보석을 넣었을 때 배낭이 터지지 않아야 한다)

<img width="661" alt="스크린샷 2023-04-07 오전 11 54 48" src="https://user-images.githubusercontent.com/87372606/230531752-756f1f80-ce49-4d78-8941-ce16782afef7.png">

- P[i, w] 란 i 개의 보석이 있고 배낭의 무게 한도가 w일 때 최적의 이익을 의미

  - i 번째 보석이 **배낭의 무게 한도보다 무거우면 넣을 수 없으므로 i 번째 보석을 뺀 i-1 개의 보석들을 가지고 구한 전 단계의 최적값**을 그대로 가져온다.

  - 그렇지 않은 경우, **i 번째 보석을 위해 i 번째 보석만큼의 무게를 비웠을 때의 최적값에 i 번째 보석의 가격을 더한 값** or **i-1 개의 보석들을 가지고 구한 전 단계의 최적값** 중 `큰 것을 선택`한다

```
백준 12865번

for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= K; j++)
        {

            if (j - W[i] >= 0)
                DP[i][j] = max(DP[i - 1][j], DP[i - 1][j - W[i]] + V[i]);
            else
                DP[i][j] = DP[i - 1][j];
        }
    }
```

**Reference**

- [Dynamic Programming: 배낭 채우기 문제](https://gsmesie692.tistory.com/113)
